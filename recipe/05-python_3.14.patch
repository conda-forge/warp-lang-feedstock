# From git diff 5ddc94f042dc7a41d22911dcff7800ab6da3be29^ 5ddc94f042dc7a41d22911dcff7800ab6da3be29 -- warp > 05-python_3.14.patch
diff --git a/warp/codegen.py b/warp/codegen.py
index 7bf6cc77..dee703bd 100644
--- a/warp/codegen.py
+++ b/warp/codegen.py
@@ -53,6 +53,22 @@ class WarpCodegenAttributeError(AttributeError):
         super().__init__(message)
 
 
+def get_node_name_safe(node):
+    """Safely get a string representation of an AST node for error messages.
+
+    This handles different AST node types (Name, Subscript, etc.) without
+    raising AttributeError when accessing attributes that may not exist.
+    """
+    if hasattr(node, "id"):
+        return node.id
+    elif hasattr(node, "value") and hasattr(node, "slice"):
+        # Subscript node like inputs[tid]
+        base_name = get_node_name_safe(node.value)
+        return f"{base_name}[...]"
+    else:
+        return f"<{type(node).__name__}>"
+
+
 class WarpCodegenKeyError(KeyError):
     def __init__(self, message):
         super().__init__(message)
@@ -185,23 +201,39 @@ def eval_annotations(annotations: Mapping[str, Any], obj: Any) -> Mapping[str, A
 
 def get_annotations(obj: Any) -> Mapping[str, Any]:
     """Same as `inspect.get_annotations()` but always returning un-stringized annotations."""
-    # This backports `inspect.get_annotations()` for Python 3.9 and older.
-    # See https://docs.python.org/3/howto/annotations.html#accessing-the-annotations-dict-of-an-object-in-python-3-9-and-older
-    if isinstance(obj, type):
-        annotations = obj.__dict__.get("__annotations__", {})
+    # Python 3.10+: Use the built-in inspect.get_annotations() which handles
+    # PEP 649 (deferred annotation evaluation) in Python 3.14+
+    if hasattr(inspect, "get_annotations"):
+        # eval_str=True ensures stringized annotations from PEP 563 are evaluated
+        return inspect.get_annotations(obj, eval_str=True)
     else:
-        annotations = getattr(obj, "__annotations__", {})
+        # Python 3.9 and older: Manual backport of inspect.get_annotations()
+        # See https://docs.python.org/3/howto/annotations.html#accessing-the-annotations-dict-of-an-object-in-python-3-9-and-older
+        if isinstance(obj, type):
+            annotations = obj.__dict__.get("__annotations__", {})
+        else:
+            annotations = getattr(obj, "__annotations__", {})
 
-    # Evaluating annotations can be done using the `eval_str` parameter with
-    # the official function from the `inspect` module.
-    return eval_annotations(annotations, obj)
+        return eval_annotations(annotations, obj)
 
 
 def get_full_arg_spec(func: Callable) -> inspect.FullArgSpec:
     """Same as `inspect.getfullargspec()` but always returning un-stringized annotations."""
-    # See https://docs.python.org/3/howto/annotations.html#manually-un-stringizing-stringized-annotations
     spec = inspect.getfullargspec(func)
-    return spec._replace(annotations=eval_annotations(spec.annotations, func))
+
+    # Python 3.10+: Use inspect.get_annotations()
+    if hasattr(inspect, "get_annotations"):
+        # Capture closure variables to handle cases like `foo.Data` where `foo` is a closure variable
+        closure_vars = dict(
+            zip(func.__code__.co_freevars, (get_closure_cell_contents(x) for x in (func.__closure__ or ())))
+        )
+        # Filter out None values from empty cells
+        closure_vars = {k: v for k, v in closure_vars.items() if v is not None}
+        return spec._replace(annotations=inspect.get_annotations(func, eval_str=True, locals=closure_vars))
+    else:
+        # Python 3.9 and older: Manually un-stringize annotations
+        # See https://docs.python.org/3/howto/annotations.html#manually-un-stringizing-stringized-annotations
+        return spec._replace(annotations=eval_annotations(spec.annotations, func))
 
 
 def struct_instance_repr_recursive(inst: StructInstance, depth: int, use_repr: bool) -> str:
@@ -2047,8 +2079,9 @@ class Adjoint:
                 return type_attribute
 
             if isinstance(aggregate, Var):
+                node_name = get_node_name_safe(node.value)
                 raise WarpCodegenAttributeError(
-                    f"Error, `{node.attr}` is not an attribute of '{node.value.id}' ({type_repr(aggregate.type)})"
+                    f"Error, `{node.attr}` is not an attribute of '{node_name}' ({type_repr(aggregate.type)})"
                 ) from e
             raise WarpCodegenAttributeError(f"Error, `{node.attr}` is not an attribute of '{aggregate}'") from e
 
diff --git a/warp/context.py b/warp/context.py
index ec73c378..43cdfd82 100644
--- a/warp/context.py
+++ b/warp/context.py
@@ -1207,8 +1207,13 @@ def overload(kernel, arg_types=Union[None, Dict[str, Any], List[Any]]):
         for node in func_body:
             if isinstance(node, ast.Pass):
                 continue
-            elif isinstance(node, ast.Expr) and isinstance(node.value, (ast.Str, ast.Ellipsis)):
-                continue
+            elif isinstance(node, ast.Expr):
+                # Python 3.8+ uses ast.Constant for strings and Ellipsis
+                # Python 3.14+ removed ast.Str and ast.Ellipsis (deprecated since 3.8)
+                if isinstance(node.value, ast.Constant) and (
+                    isinstance(node.value.value, str) or node.value.value is ...
+                ):
+                    continue
             raise RuntimeError(
                 "Illegal statement in kernel overload definition.  Only pass, ellipsis (...), comments, or docstrings are allowed"
             )
diff --git a/warp/tests/test_func.py b/warp/tests/test_func.py
index eb72fd82..d45a8e7f 100644
--- a/warp/tests/test_func.py
+++ b/warp/tests/test_func.py
@@ -443,10 +443,7 @@ class TestFunc(unittest.TestCase):
             a * b
 
     def test_cpython_call_user_function_with_error(self):
-        with self.assertRaisesRegex(
-            ZeroDivisionError,
-            "float division by zero",
-        ):
+        with self.assertRaises(ZeroDivisionError):
             divide_by_zero(1.0)
 
     def test_cpython_call_user_function_with_wrong_argument_types(self):
diff --git a/warp/tests/test_static.py b/warp/tests/test_static.py
index 98629534..7d3f9c99 100644
--- a/warp/tests/test_static.py
+++ b/warp/tests/test_static.py
@@ -155,7 +155,7 @@ def test_invalid_static_expression(test, device):
         wp.static(1.0 / 0.0)
 
     with test.assertRaisesRegex(
-        warp.codegen.WarpCodegenError, r"Error evaluating static expression\: float division by zero"
+        warp.codegen.WarpCodegenError, r"Error evaluating static expression\: (?:float )?division by zero"
     ):
         wp.launch(invalid_kernel, 1, device=device)
 
